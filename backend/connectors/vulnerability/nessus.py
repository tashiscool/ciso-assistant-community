"""
Tenable Nessus Connector.

Provides vulnerability scanning and assessment capabilities.
"""

from dataclasses import dataclass, field
from typing import Any, List, Optional
import logging
import httpx

from ..base.connector import (
    BaseConnector, ConnectorCategory, ConnectorConfig, ConnectorResult, AuthenticationError
)
from ..base.registry import ConnectorRegistry

logger = logging.getLogger(__name__)


@dataclass
class NessusVulnerability:
    """Represents a Nessus vulnerability finding."""
    id: str
    plugin_id: str
    plugin_name: str
    severity: str
    severity_index: int
    host_ip: str
    host_name: Optional[str]
    port: Optional[int]
    protocol: Optional[str]
    cve_ids: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    description: Optional[str] = None
    solution: Optional[str] = None
    plugin_output: Optional[str] = None
    first_seen: Optional[str] = None
    last_seen: Optional[str] = None


@ConnectorRegistry.register
class NessusConnector(BaseConnector[NessusVulnerability]):
    """Connector for Tenable Nessus."""

    connector_type = "nessus"
    display_name = "Tenable Nessus"
    description = "Vulnerability scanner for identifying security weaknesses"
    category = ConnectorCategory.VULNERABILITY
    supported_auth_types = ["api_key"]
    supports_sync = True
    supports_webhook = False

    TENABLE_IO_API = "https://cloud.tenable.com"

    def __init__(self, config: ConnectorConfig):
        super().__init__(config)
        self._access_key: Optional[str] = None
        self._secret_key: Optional[str] = None

    async def validate_config(self) -> ConnectorResult:
        required = ["access_key", "secret_key"]
        missing = [f for f in required if not self.config.credentials.get(f)]
        if missing:
            return ConnectorResult(success=False, error_message=f"Missing: {', '.join(missing)}", error_code="MISSING_CREDENTIALS")
        return ConnectorResult(success=True)

    async def test_connection(self) -> ConnectorResult:
        try:
            await self.authenticate()
            api_base = self.config.base_url or self.TENABLE_IO_API
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{api_base}/session",
                    headers={
                        "X-ApiKeys": f"accessKey={self._access_key};secretKey={self._secret_key}"
                    },
                    timeout=self.config.timeout_seconds
                )
                if response.status_code == 200:
                    return ConnectorResult(success=True)
            return ConnectorResult(success=False, error_message="API connection failed", error_code="CONNECTION_ERROR")
        except Exception as e:
            return ConnectorResult(success=False, error_message=str(e), error_code="CONNECTION_ERROR")

    async def authenticate(self) -> ConnectorResult:
        self._access_key = self.config.credentials.get("access_key")
        self._secret_key = self.config.credentials.get("secret_key")
        if not self._access_key or not self._secret_key:
            raise AuthenticationError("API keys not configured")
        return ConnectorResult(success=True)

    async def fetch_data(self, **kwargs) -> ConnectorResult:
        if not self._access_key:
            return ConnectorResult(success=False, error_message="Not authenticated", error_code="NOT_AUTHENTICATED")

        api_base = self.config.base_url or self.TENABLE_IO_API
        all_vulns = []

        try:
            async with httpx.AsyncClient() as client:
                headers = {"X-ApiKeys": f"accessKey={self._access_key};secretKey={self._secret_key}"}

                # Export vulnerabilities
                export_response = await client.post(
                    f"{api_base}/vulns/export",
                    headers=headers,
                    json={
                        "filters": kwargs.get("filters", {}),
                        "num_assets": kwargs.get("num_assets", 500)
                    },
                    timeout=self.config.timeout_seconds
                )

                if export_response.status_code != 200:
                    return ConnectorResult(success=False, error_message="Export request failed", error_code="API_ERROR")

                export_uuid = export_response.json().get("export_uuid")

                # Poll for completion
                import asyncio
                for _ in range(60):
                    status_response = await client.get(
                        f"{api_base}/vulns/export/{export_uuid}/status",
                        headers=headers,
                        timeout=self.config.timeout_seconds
                    )
                    status = status_response.json().get("status")
                    if status == "FINISHED":
                        break
                    await asyncio.sleep(5)

                # Download chunks
                chunks_response = await client.get(
                    f"{api_base}/vulns/export/{export_uuid}/status",
                    headers=headers,
                    timeout=self.config.timeout_seconds
                )
                chunks = chunks_response.json().get("chunks_available", [])

                for chunk_id in chunks:
                    chunk_response = await client.get(
                        f"{api_base}/vulns/export/{export_uuid}/chunks/{chunk_id}",
                        headers=headers,
                        timeout=self.config.timeout_seconds * 2
                    )
                    if chunk_response.status_code == 200:
                        all_vulns.extend(chunk_response.json())

            return ConnectorResult(success=True, data=all_vulns, items_processed=len(all_vulns))
        except Exception as e:
            return ConnectorResult(success=False, error_message=str(e), error_code="FETCH_ERROR")

    async def transform_data(self, raw_data: Any) -> List[NessusVulnerability]:
        vulns = []
        severity_map = {0: "info", 1: "low", 2: "medium", 3: "high", 4: "critical"}
        for v in raw_data:
            asset = v.get("asset", {})
            plugin = v.get("plugin", {})
            vulns.append(NessusVulnerability(
                id=f"{asset.get('uuid', '')}:{plugin.get('id', '')}",
                plugin_id=str(plugin.get("id", "")),
                plugin_name=plugin.get("name", ""),
                severity=severity_map.get(v.get("severity", 0), "unknown"),
                severity_index=v.get("severity", 0),
                host_ip=asset.get("ipv4", ""),
                host_name=asset.get("hostname"),
                port=v.get("port", {}).get("port"),
                protocol=v.get("port", {}).get("protocol"),
                cve_ids=plugin.get("cve", []),
                cvss_score=plugin.get("cvss_base_score"),
                description=plugin.get("description"),
                solution=plugin.get("solution"),
                plugin_output=v.get("output"),
                first_seen=v.get("first_found"),
                last_seen=v.get("last_found"),
            ))
        return vulns

    def get_config_schema(self) -> dict:
        base = super().get_config_schema()
        base["properties"].update({
            "access_key": {"type": "string", "description": "Tenable.io Access Key"},
            "secret_key": {"type": "string", "format": "password", "description": "Tenable.io Secret Key"},
        })
        base["required"].extend(["access_key", "secret_key"])
        return base
